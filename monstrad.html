<!-- Monstrad - a puzzle game inspired by NAWNCO (by Increpare). -->

<!-- Comment tag meanings

`OLD    I plan to remove the following code, but I'm keeping it around for reference or to prevent bugs from popping up.

`TODO   The following code needs to be filled in, but not quite yet.

`NOTE   Just a note about the following code.

`???    A note about something I'm unsure of.

`IDEA   An idea.

`       Some other note to myself which I want to keep track of.

-->

<html>
  <head>
    <script type="text/javascript" src="akihabara/gbox.js"></script>
    <script type="text/javascript" src="akihabara/iphopad.js"></script>
    <script type="text/javascript" src="akihabara/trigo.js"></script>
    <script type="text/javascript" src="akihabara/toys.js"></script>
    <script type="text/javascript" src="akihabara/help.js"></script>
    <script type="text/javascript" src="akihabara/tool.js"></script>
    <script type="text/javascript" src="akihabara/gamecycle.js"></script>
    <script type="text/javascript" src="akihabara/mouse.js"></script>
    <style>BODY { -webkit-user-select: none; margin: 0px }</style>
  </head>
  <body></body>
  
  <script id=utility>
	// These are utility functions and other detritus.
    // They're necessary for the game, but completely separable (in
    // the sense that they could be re-used for other Akihabara games).
	String.prototype.lpad = function(padString, length) {
		var str = this;
		while (str.length < length)
			str = padString + str;
		return str;
	}
	String.prototype.rpad = function(padString, length) {
		var str = this;
		while (str.length < length)
			str = str + padString;
		return str;
	}
    function xy(coord_x, coord_y) {
		return {x:coord_x, y:coord_y}
	}
	function wh(width, height) {
		return {w:width, h:height}
	}
	function randomItem(array) {
        return array[help.random(0, array.length)];
    }
    function clearBuffer() {
        // Clears the game screen.
		
        gbox.blitFade(gbox.getBufferContext(), {color: bg_color, alpha: 1});
    }
    function disableIntro(maingamevar) {
        // Disable the title/intro routines
        maingamevar.gameMenu = function() { return true; };
        maingamevar.gameTitleIntroAnimation = function(){ return true; };
        maingamevar.gameIntroAnimation = function(){ return true; };
		maingamevar.pressStartIntroAnimation = function(reset) {return true};
	}
	function blitDebug(txt) {
		gbox.blitText(gbox.getBufferContext(), {font:gbox._dbf, text:txt, dy:0, dx:0});
	}
	
	gbox._keymap.enter = 13;
	gbox._keymap.shift = 16;
	gbox._keymap.tab = 9;
	gbox._keymap.space = 32;
	gbox._keymap.plus = 187;
	gbox._keymap.minus = 189;
	gbox._keymap.backspace = 8;
	gbox._keymap.n = 78;
	gbox._keymap.r = 82;
	gbox._keymap.s = 83;
    gbox._keymap.one = 49;
    gbox._keymap.two = 50;
    gbox._keymap.three = 51;
    gbox._keymap.four = 52;
    gbox._keymap.five = 53;
	letter_translation = [[null, ' '], [0, 'a'], [1, 'b'], [2, 'c'], [3, 'd'], [4, 'e'], [5, 'f'], [6, 'g'], [7, 'h'], [8, 'i'], [9, 'j'], [10, 'k'], [11, 'l'], [12, 'm'], [13, 'n'], [14, 'o'], [15, 'p'], [16, 'q'], [17, 'r'], [18, 's'], [19, 't'], [20, 'u'], [21, 'v'], [22, 'w'], [23, 'x'], [24, 'y'], [25, 'z']]
  </script>
  
  <script id=game_vars>
    // GLOBAL GAME CONSTANTS AND VARIABLES
    var maingame;
	var bg_color = "rgb(0,0,20)"
	
	var goal_level = 4;
	
	var board_layers;
	
	// Size of the smallest monad (pixels)
    var tilesize = 20;
    
	// Size of the board, in tiles
	var board_width = 16;
    var board_height = 16;
	var board_area = wh(board_width*tilesize, board_height*tilesize);
	
	// Position of the board's top-left corner
	var board_x0 = 40;
	var board_y0 = 100;
	
	// Position of the monad panel (top-left corner)
	var mp_x0 = 440;
	var mp_y0 = board_y0 + 1.5*tilesize;
	
	// Position of game title
	var title_x0 = board_x0;
	var title_y0 = 20;
	
	// Position of the message text
	var message_x0 = title_x0 + 100;
	var message_y0 = title_y0;
	
	// Position of the player score label
	var score_x0 = mp_x0;
	var score_y0 = title_y0;
	
	
	// Monster cursor image data
	var cursor_width = 48;
	var cursor_height = 54;
	var cursor_x = 3;
	var cursor_y = 9;
	
	// Camera buffer widths
	var buffer_x = 5*tilesize;
	var buffer_y = 5*tilesize;
	
	// A useful hash/object thing for evaluating directions
	dir_coords = {'left': xy(-1,  0),
				 'right': xy(+1,  0),
				 'up':    xy( 0, -1),
				 'down':  xy( 0, +1)};
    
    // These have the same order as the species in the monad image.
    var species = ["1111", "1222", "1211", "1112",
                   "1121", "1212", "1122", "1221",
                   "1123", "1213", "1233", "1232",
                   "1231", "1223", "1234"];
	var blank = 15; // the index of the blank tile on the tilemap
	
	// SPECIES GROUPS
	
	var species_grp_names = {
		"stone": ["1111"],
		"satellite": ["1222", "1211", "1112", "1121"],
		"road":["1212", "1122"],
		"cross": ["1221"],
		"coast": ["1123", "1213", "1233", "1232"],
		"border":  ["1231", "1223"],
		"water":   ["1234"]
	};
	
	var species_grps = {
		"1111":"stone",
		"1222":"satellite",
		"1211":"satellite",
		"1112":"satellite",
		"1121":"satellite",
		"1212":"road",
		"1122":"road",
		"1221":"cross",
		"1123":"coast",
		"1213":"coast",
		"1233":"coast",
		"1232":"coast",
		"1231":"border",
		"1223":"border",
		"1234":"water"
	};
	
	var point_values = {
		"stone": 20,
		"cross": 15,
		"road":10,
		"satellite": 5,
		"coast": 1,
		"border":  1,
		"water":   0,
	}
	
	// MIRROR IMAGES OF MONADS
	var mirrors_vertical = {
		0:0,
		1:2, 2:1, 3:4, 4:3,
		5:5, 6:6,
		7:7,
		8:8, 9:11, 10:10, 11:9,
		12:13, 13:12,
		14:14,
		15:15
	}
	var mirrors_horizontal = {
		0:0,
		1:4, 2:3, 3:2, 4:1,
		5:5, 6:6,
		7:7,
		8:10, 9:9, 10:8, 11:11,
		12:13, 13:12,
		14:14,
		15:15
	}
	var mirrors_NeSw = {
		0:0,
		1:1, 2:4, 3:3, 4:2,
		5:6, 6:5,
		7:7,
		8:9, 9:8, 10:11, 11:10,
		12:12, 13:13,
		14:14,
		15:15
	}
	var mirrors_NwSe = {
		0:0,
		1:3, 2:2, 3:1, 4:4,
		5:6, 6:5,
		7:7,
		8:11, 9:10, 10:9, 11:8,
		12:12, 13:13,
		14:14,
		15:15
	}
	// PLAYER SCORE
	var score = 0;
	
  </script>
  
  <script id=game_boards>
	/*
	TUTORIAL BOARDS
	*/
	
	// 1. Introducing the way to build monads
	// build monads by 
	tut1a = [[1, 2], [2, 1]];
	tut1b = [[1, 2], [3, 2]];
	tut1c = [[1, 2], [3, 4]];
	
	// 2. Multiple monads on a larger board
	tut2 = [[1, 2, 3, 3], [4, 2, 5, 3]];
	
	
	tut3 = [[1, 2, 3, 3], [2, 1, 3, 3], ['a', 6, 8, 8], [7, 7, 9, 8]];
	
  </script>
  
  <script id=game_helpers>
    // GAME-RELATED HELPER FUNCTIONS AND SHORTCUTS
	function logMap(board) { //`OLD
		console.log("Board", board.id, "is:");
		console.log('  0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15  ');
		console.log('-----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+-----');
		for (var i in board.map) {
			var row = [];
			for (j in board.map[i]) row.push( board.map[i][j]==null? '    ' : (typeof board.map[i][j]=="string")? ' ** ' : board.map[i][j].toString().lpad(' ', 3)+' ');
			console.log('|' + row.join('|') + "|");
			console.log('|----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----|');
		}
	}
    function pointCamera() {
	  var cam = gbox.getCamera();
	  var cursor = gbox.getObject('cursor', 'monster');
	  var x = (cursor.x+1)*tilesize; var y = (cursor.y+1)*tilesize;
	  var W = gbox._screenw;         var H = gbox._screenh;
	 
	  if ((x - cam.x) < (buffer_x))     gbox.setCameraX(cam.x + (x - cam.x) - buffer_x,       board_area);
	  if ((y - cam.y) < (buffer_y))     gbox.setCameraY(cam.y + (y - cam.y) - buffer_y,       board_area);
	  if ((x - cam.x) > (W - buffer_x)) gbox.setCameraX(cam.x + (x - cam.x) - (W - buffer_x), board_area);
	  if ((y - cam.y) > (H - buffer_y)) gbox.setCameraY(cam.y + (y - cam.y) - (H - buffer_y), board_area);
	}
	function display(text) {
		maingame.hud.setValue('message', 'value', text);
		maingame.hud.redraw();
	}
	function outOfBounds(x, y) {
		return (x<0 || y<0 || x>board_width || y>board_height)
	}
	function makeNullMap(w, h) {
        // Lists of position indices for the map array
        cols = help.seq(0, w);
        rows = help.seq(0, h);
        
        // Initialize the map array
        var map = new Array(h);
        for (var i in rows) {
			map[i] = new Array(w);
			for (var j in cols) map[i][j]=null;
		}
		
		return map;
	}
	function makeBlankMap(w, h) { //`OLD
        // Lists of position indices for the map array
        cols = help.seq(0, w);
        rows = help.seq(0, h);
        
        // Initialize the map array
        var map = new Array(h);
        for (var i in rows) {
			map[i] = new Array(w);
			for (var j in cols) map[i][j]=blank;
		}
		
		return map;
	}
	function makeRandomMap(w, h) { //`OLD
        // This function must return a 2d array of INDICES.
        // The indices refer to WHICH MONADS from the monad tilemap
        // get placed in a particular array spot.
		
        // Lists of position indices for the map array
        cols = help.seq(0, w);
        rows = help.seq(0, h);
        
        // Initialize the map array
        var map = new Array(h);
        for (var i in rows) { map[i] = new Array(w); }
        
        // Put random indices in it
        for (var i in rows) for (var j in cols) {
            map[i][j] = help.random(0, species.length);
        }
        
        return map;
    }
	function loadNewBoard(int_map) {
		var new_map = help.asciiArtToMap(evalRandomMap(int_map), letter_translation);
		
		board_height = new_map.length;
		board_width = new_map[0].length;
		board_area = {w:board_width*tilesize, h:board_height*tilesize};
		
		for (i in board_layers) {
			var b = board_layers[i];
			var canvas = gbox.getCanvas(b.id + '_canvas');
			canvas.width = board_area.w;
			canvas.height = board_area.h;
			b.map = b.id=='b1'? new_map : makeBlankMap(board_width, board_height);
			help.finalizeTilemap(b);
			b.refreshTilemap();
		}
		
		var cursor = gbox.getObject('cursor', 'monster');
		cursor.board = board_layers[0];
		cursor.x=0;
		cursor.y=0;
	}
	function getCanvas(board_id) {
        // Retrieves a board's HTML canvas.
        return gbox.getCanvas(board_id+"_canvas");
    }
    function getContext(board_id) {
        // Retrieves a board's HTML canvas context.
        //return gbox.getCanvasContext(board_id+"_canvas");
		return getCanvas(board_id).getContext("2d");
    }
    function getBoard(board_id) {
        // Retrieves a board object.
        return gbox.getObject('boards', board_id);
    }
    function generateMonad(tetrad_list, combine_grps) {
		// Returns the INDEX (in the species list) of the monad generated from
		// the given tetrad. The monads in the tetrad list should also be indices.
		var monads = {};
		var new_monad = [];
		var numbers = ['4', '3', '2', '1'];
		for (var i in tetrad_list) {
			m = tetrad_list[i];
			if (combine_grps) m = species_grps[species[m]];
			if (!(m in monads)) monads[m] = numbers.pop();
			new_monad.push(monads[m]);
		}
		return species.indexOf(new_monad.join(""));
	}
	function scoreMonad(monad, multiplier) {
		score += point_values[monad];
		maingame.hud.setValue('score', 'value', "Score: "+score.toString());
		
		display("You found a "+monad+"! +"+point_values[monad].toString());
	}
	function resetScore() {
		score = 0;
	}
	function evalRandomMap(int_map, exclude) {
		/* This method takes a 2d array of numbers and converts it to an ASCII board map which is readable by help.asciiArtToMap.
		The catch is: the numbers only designate which monads in the
		board are the same. So the number 1 would represent any random
		monad, but multiple 1s on the same board would be the same 
		random monad.
		Used for generating a board from a template.*/
		
		// 1. Match integers to random monads
		
		var random_letters = {};
		
		// This code block would be for the 'hard' difficulty (separate monads)
		/*
		var letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o']; // Only 15 are needed
		for (var i=0; i<15; i++) {
			random_letters[i] = letters.splice(help.random(0, letters.length), 1)[0];
		}
		*/
		
		// This code block is for normal difficulty (monad groups)
		var letters = [['a'], ['b', 'c', 'd', 'e'], ['f', 'g'], ['h'], ['i', 'j', 'k', 'l'], ['m', 'n'], ['o']];
		
		// Take out excludable letters (specified in the exclude argument)
		k = 7;
		/*
		if (exclude && exclude.length>0) 
			for (var i=0; i<7; i++) {
				for (j in exclude) {
					if (letters[i].indexOf(exclude[j])!=-1) 
				}
			}
		*/
		for (var i=0; i<k; i++) {
			random_letters[i] = letters.splice(help.random(0, letters.length), 1)[0];
		}
		// Put more numbers in just in case the int_map template has numbers up to 15
		letters = [['a'], ['b', 'c', 'd', 'e'], ['f', 'g'], ['h'], ['i', 'j', 'k', 'l'], ['m', 'n'], ['o']];
		for (var i=k; i<15; i++) {
			random_letters[i] = letters.splice(help.random(0, letters.length), 1)[0];
		}
		
		
		// 2. Apply it to the board map
		var ascii_map = [];
		for (row in int_map) {
			var new_row = "";
			
			// This is for the hard difficulty
			// (Doesn't do potential letters in the int map, or excludable letters)
			//for (i in int_map[row]) new_row += random_letters[int_map[row][i]];
			
			// This is for the normal difficulty
			for (i in int_map[row]) {
				if (typeof int_map[row][i] == "number") {
					grp = random_letters[int_map[row][i]];
					new_row += grp[help.random(0, grp.length)];
				}
				else new_row += int_map[row][i];
			}
			
			ascii_map.push(new_row);
		}
		
		return ascii_map;
	}
	function getCoordsFromMonadString(mstring) {
		/*Converts a string of the format "m_i_j" (where i and j are integers) to {x:i, y:j}. */
		// Long name for a small function.
		var coords = mstring.split("_");
		return xy(parseInt(coords[1]), parseInt(coords[2]));
	}
		
		
  </script>

  <script id=game_methods>  
    // MAIN GAME METHODS
    window.addEventListener('load', loadResources, false);
    function main() {        
        // Specify the object groups, in a certain order
        gbox.setGroups(['background', 'boards', 'cursor', 'game']); 

        // Create the maingame; specify the title/intro routines
        maingame = gamecycle.createMaingame('game', 'game');
        
		// GAMECYCLE METHODS
		
		// 100, 101, 102: Title sequence animation
		maingame.gameTitleIntroAnimation = function(reset) {
			clearBuffer();
			gbox.blitText(gbox.getBufferContext(),{
				font:"large",
				text:"MONSTRAD",
				//valign:gbox.ALIGN_MIDDLE,
				halign:gbox.ALIGN_CENTER,
				dx:0,dy:80,
				dw:gbox.getScreenW()});
		}
		
		// 100: After staring at the title a bit, the player presses start
		maingame.pressStartIntroAnimation = function(reset) {
			params = {font:"small", halign:gbox.ALIGN_CENTER, dx:0, dy:0, dw:gbox.getScreenW(), blit: function() {gbox.blitText(gbox.getBufferContext(), params)}
			};
			
			params.dy=170;
			params.text="Your mission: to find and build the largest stone monad.";
			params.blit();
			
			params.dy=200;
			params.text="Move around the landscape of monads with the arrow keys."
			params.blit();
			
			params.dy=230;
			params.text="Build groups of four monads by pressing enter.";
			params.blit();
			
			params.dy=260;
			params.text="Take care when building stone or water monads.";
			params.blit();
			
			params.dy=320;
			params.font="large";
			params.text="Hit enter to continue. Good luck!";
			params.blit();
			
			return gbox.keyIsHit("enter");
        };
		
		// 101: Game menu
		// **** A nested menu for practice levels? Sort of?
		// **** Call this.goToLevel(lvl) instead of returning true (??)
		// **** You might want to just skip to state 401.
		maingame.gameMenu = function(reset) {
			//clearBuffer();
			
			// `TODO: Blit some text saying "Which level/landscape would you like to tackle?"
			
			menu_params = {
				font:"large",
				keys:{up:"up",down:"down",ok:"enter",cancel:"backspace"},
				selector:">",
				x:200, y:200,
				items:["Tutorial","Practice","Real World"],
			};
			// Specifying a selected parameter (e.g. selected:"Practice") I think will set which level is initially selected
			
			// `TODO (optional): Blit a graphical menu for the player to choose which tutorial to play
			
			if (toys.ui.menu(this, "difficulty", menu_params)) {
				if (toys.getToyValue(this, "difficulty", "ok") == -1) return -1;
				else {
					this.difficulty=toys.getToyValue(this, "difficulty", "selected");
					return true;
				}
			}
		}
        
		// 200: Introduction animation
		maingame.gameIntroAnimation = function(reset){
			clearBuffer();
		};
		
		// 400: Finish a level
		maingame.endlevelIntroAnimation = function(reset) { return true; }
		
		// 401: Start a level
		maingame.levelIntroAnimation = function(reset) { return true; }
		
		// 801: End of game ("You made the huge stone monad!")
		maingame.gameEndingIntroAnimation = function(reset) { return true; }
		
		// 700: Game over ("Yay!")
		maingame.gameoverIntroAnimation = function(reset) { return true; }
		
		// 301: Normal gameplay
		maingame.gameEvents = function(reset) { return true; }
		
		
		disableIntro(maingame); // Disable stuff for now
		
		// GAME INITIALIZATION
		
		// Initialize boards.
		board_layers = [
			createBoard('b1', {
				next_board_id: 'b2',
				map: makeNullMap(board_width, board_height)
				//map: help.asciiArtToMap(initial_board, letter_translation)
			}),
			createBoard('b2', {
				scale: 2,
				last_board_id: 'b1',
				next_board_id: 'b3',
				map: makeBlankMap(board_width, board_height)
			}),
			createBoard('b3', {
				scale: 4,
				last_board_id: 'b2',
				next_board_id: 'b4',
				map:   makeBlankMap(board_width, board_height)
			}),
			createBoard('b4', {
				scale: 8,
				last_board_id: 'b3',
				next_board_id: 'b4',
				map:   makeBlankMap(board_width, board_height)
			})
		]
		
		// Monad panel
		mp = createBoard('monad_panel', {
			x: mp_x0+90,
			y: mp_y0,
			map: help.asciiArtToMap(['a   ', '    ', 'h   ', '    ', 'fg  ', '    ', 'dceb', '    ', 'jkli', '    ', 'mn  ', '    ', 'o   '], letter_translation)
		});
		
        maingame.initializeGame = function() {
            gbox.addObject(background());
			
			// Player object - contains info like the player's level
			gbox.addObject(player());
			
			// Boards and monster cursor
			for (i in board_layers) gbox.addObject(board_layers[i]);
			
			board_layers[1].fillRandomly();
			gbox.addObject(monster('b2'));
			
			//`TODO:
			//board_layers[0].fillWithBlanks();
			//...etc
            
			// HUD
			maingame.hud.setWidget('game_title', {
				widget: 'label',
				font:   'small',
				value:  "TETRAD",
				dx:     title_x0,
				dy:     title_y0,
				clear: true
			});
			maingame.hud.setWidget('score', {
				widget: 'label',
				font:   'small',
				value:  "SCORE: 0",
				dx:     score_x0,
				dy:     score_y0,
				clear: true
			});
			maingame.hud.setWidget('message', {
				widget: 'label',
				font:   'small',
				value:  "",
				dx:     message_x0,
				dy:     message_y0,
				clear: true
			});
			gbox.addObject(mp);// `TODO: Instead of manually putting the points text here, use the species_grps_points var
			maingame.hud.setWidget('pts_stone', {
				widget: 'label',
				font:   'small',
				value:  "20 points",
				dx:     mp_x0,
				dy:     mp_y0+6,
				clear: true
			});
			maingame.hud.setWidget('pts_cross', {
				widget: 'label',
				font:   'small',
				value:  "15 points",
				dx:     mp_x0,
				dy:     mp_y0+6 + 2*tilesize,
				clear: true
			});
			maingame.hud.setWidget('pts_road', {
				widget: 'label',
				font:   'small',
				value:  "10 points",
				dx:     mp_x0,
				dy:     mp_y0+6 + 4*tilesize,
				clear: true
			});
			maingame.hud.setWidget('pts_satellite', {
				widget: 'label',
				font:   'small',
				value:  "5 points",
				dx:     mp_x0,
				dy:     mp_y0+6 + 6*tilesize,
				clear: true
			});
			maingame.hud.setWidget('pts_coast', {
				widget: 'label',
				font:   'small',
				value:  "1 point",
				dx:     mp_x0,
				dy:     mp_y0+6 + 8*tilesize,
				clear: true
			});
			maingame.hud.setWidget('pts_border', {
				widget: 'label',
				font:   'small',
				value:  "1 point",
				dx:     mp_x0,
				dy:     mp_y0+6 + 10*tilesize,
				clear: true
			});
			maingame.hud.setWidget('pts_water', {
				widget: 'label',
				font:   'small',
				value:  "0 points",
				dx:     mp_x0,
				dy:     mp_y0+6 + 12*tilesize,
				clear: true
			});
			
			//`Temporary testing variables
			c = gbox.getObject('cursor', 'monster');
			cam = gbox.getCamera();
			b1 = board_layers[0];
			b2 = board_layers[1];
			b3 = board_layers[2];
			b4 = board_layers[3];
			p = gbox.getObject('game', 'player');
        };
        
        gbox.go();
    }
    function createBoard(board_id, params) {
		var board = {
            id:      board_id,
            group:   'boards',
            tileset: 'monad_tiles',
			scale:   params.scale?params.scale:1,
			map:	 params.map,
            x: params.x ? params.x : board_x0,
			y: params.y ? params.y : board_y0,
			last_board_id: params.last_board_id?params.last_board_id:board_id,
            next_board_id: params.next_board_id?params.next_board_id:board_id,
			
			//`TODO: Move various helper methods into here (like placeMonad, etc)
			
			refreshTilemap: function() {
				context = getContext(this.id);
				gbox.blitTilemap(context, this);
			},
			floor: function(integer) {
				return Math.floor(integer/this.scale)*this.scale
			},
			fillWithBlanks: function() {
				//`TODO
			},
			fillRandomly: function() {
				for (i=0; i<board_width/this.scale; i++) for (j=0; j<board_width/this.scale; j++) {
					this.placeMonad(i*this.scale, j*this.scale, help.random(0, 15)); //`TODO: give a variable name to that 15 (number of species + blank
				}
			},
			getMonad: function(x, y) {
				/* Returns the integer index for the monad at x, y. (E.g. returns 15 for a blank.) */
				if (outOfBounds(x, y)) return null;
				//console.log("monad at", x, y, "is", help.getTileInMap(x*tilesize, y*tilesize, this));
				return help.getTileInMap(x*tilesize, y*tilesize, this);
			},
			isWholeMonad: function(x, y) {
				/* Returns true if x, y is at the top-left corner of a whole monad on this board*/
				for (var i=0; i<this.scale; i++) {
					for (var j=0; j<this.scale; j++) {
						if (outOfBounds(x+i, y+j)) return false;
						if (i==0 && j==0) { if (typeof this.map[y+j][x+i]!="number") return false; }
						else if (typeof this.map[y+j][x+i] != "string") return false;
					}
				}
				return true;
			},
			getTetrad: function(x1, y1, default_monad) {
				x2 = x1 + this.scale;
				y2 = y1 + this.scale;
				if (default_monad=='wrap') {
					if (x1<0) x1+=board_width;
					if (y1<0) y1+=board_height;
					x1 %= board_width;
					x2 %= board_width;
					y1 %= board_height;
					y2 %= board_height;
				}
				var tetrad = [
				  this.getMonad(x1, y1), // NW corner
				  this.getMonad(x1, y2), // SW
				  this.getMonad(x2, y1), // NE
				  this.getMonad(x2, y2)  // SE
				]
				if (default_monad!='wrap' && default_monad!=null) {
					for (var i in tetrad) if (tetrad[i]==null) tetrad[i]=default_monad;
				}
				return tetrad;
			},
			isCompleteTetrad: function(x, y) {
				/* Returns true if the tile at x, y is the upper-left of a tetrad.
				   (Unlike getTetrad, no wrapping option is implemented.)
				*/
				for (var i=0; i<this.scale; i++) for (var j=0; j<this.scale; j++) {
					m_ij = this.getMonad(x+i, y+j);
					if (m_ij==null || m_ij==blank) return false;
				}
				return true;
				/*var m00 = this.getMonad(x,            y);
				var m10 = this.getMonad(x+this.scale, y);
				var m01 = this.getMonad(x,            y+this.scale);
				var m11 = this.getMonad(x+this.scale, y+this.scale);
				return (m00!=null  && m10!=null  && m01!=null  && m11!=null &&
						m00!=blank && m10!=blank && m01!=blank && m11!=blank)
				*/
			},
			isCompleteTetradWithBlanks: function(x, y) {
				/* Returns true if the tile at x, y is the upper-left of a tetrad (possibly with blanks).
				   (Unlike getTetrad, no wrapping option is implemented.)
				*/
				//console.log("*** xy is", x, y);
				for (var i=0; i<this.scale*2; i++) for (var j=0; j<this.scale*2; j++) {
					m_ij = this.getMonad(x+i, y+j);
					if (m_ij==null) return false;
				}
				return true;
				/*var m00 = this.getMonad(x,            y);
				var m10 = this.getMonad(x+this.scale, y);
				var m01 = this.getMonad(x,            y+this.scale);
				var m11 = this.getMonad(x+this.scale, y+this.scale);
				return (m00!=null  && m10!=null  && m01!=null  && m11!=null)
				*/
			},
			isInCompleteTetrad: function(x, y) {
				for (var i=0; i<this.scale; i++) for (var j=0; j<this.scale; j++) {
					if (this.isCompleteTetrad(x-i, y-j)) return true;
				}
				return false;
				/*return (this.isCompleteTetrad(x-1, y-1) ||
						this.isCompleteTetrad(x,   y-1) ||
						this.isCompleteTetrad(x-1, y)   ||
						this.isCompleteTetrad(x,   y))
				*/
			},
			isCompleteTetradWithBlanks: function(x, y) {
				/* Returns true if a cursor on this board can move to x, y without running into a null tile.
				*/
				//console.log("*** xy is", x, y);
				for (var i=0; i<this.scale; i++) for (var j=0; j<this.scale; j++) {
					m_ij = this.getMonad(x+i, y+j);
					if (m_ij==null) return false;
				}
				return true;
				/*var m00 = this.getMonad(x,            y);
				var m10 = this.getMonad(x+this.scale, y);
				var m01 = this.getMonad(x,            y+this.scale);
				var m11 = this.getMonad(x+this.scale, y+this.scale);
				return (m00!=null  && m10!=null  && m01!=null  && m11!=null)
				*/
			},
			eraseMonad: function(x, y) {
				/* Erases the monad at x, y. (Makes it null.) */
				if (outOfBounds(x, y)) return;
				//console.log("Erasing", this.id, "monad at", x, y, "which is", this.getMonad(x, y));
				// Make all tiles null which overlap the monad
				for (var i=0; i<this.scale; i++) {
					for (var j=0; j<this.scale; j++) {
						//console.log("Erasing tile on", this.id, "at", x+i, x+j);
						this.map[y+j][x+i]=null;
				}}
				this.refreshTilemap();
			},
			eraseTetrad: function(x, y) {
				/*Erases the tetrad with upper-left corner at x, y. (Makes the four monads null.)*/
				s = this.scale;
				this.eraseMonad(x,   y);
				this.eraseMonad(x+s, y);
				this.eraseMonad(x,   y+s);
				this.eraseMonad(x+s, y+s);
			},
			placeMonad: function(x, y, m) {
				/* Places the monad (given by its index) at the given position.*/
				if (outOfBounds(x, y)) return;
				
				// Label the tiles inside the monad as being part of the monad
				for (var i=0; i<this.scale; i++) {
					for (var j=0; j<this.scale; j++) this.map[y+j][x+i] = "m"+"_"+i.toString()+"_"+j.toString();
				}
				this.map[y][x] = m;
				this.refreshTilemap();
			},
			placeRandomMonad: function(x, y) {
				//Puts a random monad at x, y.
				//**Replaces any monad that was already there.
				if (outOfBounds(x, y)) return;
				placeMonad(x, y, help.random(0, species.length));
				this.refreshTilemap();
			},
			placeRandomTetrad: function(x, y) {
				//Puts random monads in the tetrad at x, y (upper-left corner).
				this.placeRandomMonad(x,   y);
				this.placeRandomMonad(x+1, y);
				this.placeRandomMonad(x,   y+1);
				this.placeRandomMonad(x+1, y+1);
			},
			placeMonadByPixel: function(x, y, m) {
				// Places the monad (given by its index) at the given pixel position.
				x=Math.floor(x/(tilesize));
				y=Math.floor(y/(tilesize));
				this.placeMonad(x, y, m);
			},
			findLargerMonad: function(x, y) {
				/*Recursively look for a non-blank monad that is on this board, or on a larger board
				if this one is blank.*/
				
				// If there's a valid monad on this board, return it
				m = this.getMonad(x, y);
				if (m && m!=blank) return m;
				
				// If this is the largest board, return the monad, even if it's blank
				if (this.next_board_id == this.id) return m;
				
				// Otherwise, look on the next-largest board
				return getBoard(this.next_board_id).findLargerMonad(x, y);
			},
			swapMonads: function(xy1, xy2, mirror_hash) {
				if (!this.isWholeMonad(xy1.x, xy1.y) || !this.isWholeMonad(xy2.x, xy2.y)) {
					console.log("Sorry, one of them isn't a good monad.");
					return;
				}
				m1 = this.getMonad(xy1.x, xy1.y);
				m2 = this.getMonad(xy2.x, xy2.y);
				if (mirror_hash!=null) {
					m1 = mirror_hash[m1];
					m2 = mirror_hash[m2];
				}
				this.placeMonad(xy1.x, xy1.y, m2);
				this.placeMonad(xy2.x, xy2.y, m1);
			},
			
            initialize: function() {},
            first: function() {},
            blit: function() {
                var the_canvas = getCanvas(this.id);
				
				gbox.blit(gbox.getBufferContext(), the_canvas,
                 {dx: this.x, 
                  dy: this.y,
                  dw: the_canvas.width,
                  dh: the_canvas.height,
                  sourcecamera: true
				  }
                );
            }
        };
        help.finalizeTilemap(board); // This ensures that the board has proper width/height variables 
		gbox.createCanvas(board_id+"_canvas", {w:board.w, h:board.h}); // Set up the board's HTML canvas
		board.refreshTilemap()
        return board;
    }
    function player() {
		return {
			id:'player',
			group:'game',
			level:1,
			raiseLevel: function() { this.level +=1;},
			lowerLevel: function() {this.level -=1;},
			initialize: function() {},
			first: function() {},
			blit: function() {
				//`TODO: blit HUD information here
			},
			
		};
	}
	function monster(board_id) {
        return {
            id:'monster',
            group:'cursor',
            board: getBoard(board_id), // `NOTE: Thankfully, the following is just a REFERENCE to the board object (rather than a static copy).
			tileset:'monster_tiles',  //'cursor_tile',
			x:0, y:0,
			
			// Animation parameters
			anim_state: "normal",
			anim_count: 0,
			anim_delay: 1,
			anim_skip: 1,
			
			t: null,
			m: null,
			
			// Cursor functions
			animate: function() {
				if (this.anim_state=="normal") return;
				
				anim_count = (this.anim_count-this.anim_delay)/this.anim_skip;
				
				// So far, the only animation state is eating
				if (this.anim_state=="eat_tetrad") switch (anim_count) {
					//`TODO: store these in a array or hash
					case 0: this.frame=1; break;
					case 1: this.frame=2; break;
					case 2: this.frame=3; this.eat_tetrad(); break;
					case 6: this.frame=2; break;
					case 7: this.frame=1; break;
					case 8: this.frame=0;
					  this.anim_state="normal";
					  return;
				}
				else if (this.anim_state=="eat_monad") switch(anim_count) {
					case 0: this.frame=1; break;
					case 1: this.frame=2; break;
					case 2: this.frame=3; this.eat_monad(); break;
					case 6: /*`TODO: Animate something showing that something special is happening, maybe? */ break;
					case 8: this.frame=2; break;
					case 9: this.frame=1; break;
					case 10: this.frame=0;
					  this.anim_state="normal";
					  return;
				}
				
				this.anim_count += 1;
			},
			move: function(direction, animation_exception) {
				if (this.anim_state!="normal" && !animation_exception) return;
				var next_board = getBoard(this.board.next_board_id);
				dcoords = dir_coords[direction]
				
				var new_x = this.x+dcoords.x;
				var new_y = this.y+dcoords.y;
				
				// If the cursor is sitting inside a larger monad,
				// give it opportunity to get off of it
				/*if (next_board.getMonad(this.x, this.y)!=blank) {
					new_x = this.x + dcoords.x*next_board.scale;
					new_y = this.y + dcoords.y*next_board.scale;
				}*/
				
				// Only complete the move if the cursor doesn't run into a larger monad (or the edge)
				if (this.board.isCompleteTetradWithBlanks(new_x, new_y)) {
					this.x = new_x;
					this.y = new_y;
				}
			},
            sizeup: function() {
				this.board = getBoard(this.board.next_board_id);
				
				if (this.x + this.board.scale > board_width) this.x -= (this.x+this.board.scale-board_width);
				if (this.y + this.board.scale > board_height) this.y -= (this.y+this.board.scale-board_height);
				
				display("You ate a stone!");
			},
			sizedown: function() {
				this.board = getBoard(this.board.last_board_id);
				display("You ate a water!")
			},
			eat_tetrad: function() {
				if (this.t==null) return;
				
				var m = generateMonad(this.t, true);
				getBoard(this.board.last_board_id).eraseTetrad(this.x, this.y);
				
				// Check for special monads
				// `OLD
				//if (t.indexOf(0)!=-1)  this.sizeup();	  // stone
				//if (t.indexOf(14)!=-1) this.sizedown(); // water
				//if (t.indexOf(7)!=-1)  return;			// cross: don't generate the larger monad (leave the spots empty)
				
				//`??? Do I really need to place this monad according to the pixel?
				this.board.placeMonadByPixel(this.x*tilesize, this.y*tilesize, m);
				
				scoreMonad(species_grps[species[m]], this.board.scale/2);
				
				this.freeze=false;
				this.t=null;
			},
			eat_monad: function() {
				if (this.m==null) return;
				player = gbox.getObject("game", "player");
				//console.log("Player:", player);
				
				console.log("Eating monad:", this.m);
				
				var s = this.board.scale;
				
				switch (this.m) {
					// Stone monad: level up
					case 0:
						player.raiseLevel(); 
						display("You have eaten a stone monad - time to grow bigger!");
						this.sizeup();
						break;
						
					 // Satellite monads: `?????
					case 1: case 2: case 3: case 4:
						break;
					
					// Road monads: Swap monads on opposite sides
					case 5:
						this.board.swapMonads( xy(this.x, this.y-s),
											   xy(this.x, this.y+s),
											   mirrors_vertical);
						break;
					case 6:
						this.board.swapMonads( xy(this.x-s, this.y),
											   xy(this.x+s, this.y),
											   mirrors_horizontal);
						break;
						
					// Cross monad: Swap monads on diagonals (`???)
					case 7:
						this.board.swapMonads( xy(this.x-s, this.y-s),
											   xy(this.x+s, this.y+s),
											   mirrors_NwSe);
						this.board.swapMonads( xy(this.x-s, this.y+s),
											   xy(this.x+s, this.y-s),
											   mirrors_NeSw);
						break;
					
					// Coast monad: Switch the current monad with that to its side
					case 8: 
						this.board.swapMonads( xy(this.x, this.y),
											   xy(this.x-s, this.y),
											   mirrors_horizontal);
						this.move('left', true);		 
						this.move('left', true);		 
						break;
					case 9:
						this.board.swapMonads( xy(this.x, this.y),
											   xy(this.x, this.y-s),
											   mirrors_vertical);
						this.move('up', true);
						this.move('up', true);
						break;
					case 10:
						this.board.swapMonads( xy(this.x, this.y),
											   xy(this.x+s, this.y),
											   mirrors_horizontal);
						this.move('right', true);
						this.move('right', true);
						break;
					case 11:
						this.board.swapMonads( xy(this.x, this.y),
											   xy(this.x, this.y+s),
											   mirrors_vertical);
						this.move('down', true);
						this.move('down', true);
						break;
											   
					// Border monad: Swap monads on one of the diagonals
					case 12:
						this.board.swapMonads( xy(this.x-s, this.y-s),
											   xy(this.x+s, this.y+s),
											   mirrors_NwSe);
						break;
					case 13:
						this.board.swapMonads( xy(this.x-s, this.y+s),
											   xy(this.x+s, this.y-s),
											   mirrors_NeSw);
						break;
					
					// Water monad: level down
					case 14: 
						player.lowerLevel();
						if (Math.pow(2, player.level)<this.board.scale) {
							this.sizedown();
							//`TODO: (Not necessarily here) Check for the monster being trapped with nowhere to go.
						}
				}	
			},
			
            initialize: function() {
                toys.topview.initialize(this, {});
				// Counter for keypressing
				this.n = 0;
            },
            first: function() {
				this.animate();
				min_key_frames = 3;
                //toys.topview.controlKeys(this, { left:'left', right:'right', up:'up', down:'down' });
				if (gbox.keyIsHit('left')) {
					this.move('left');
					this.n=0;
				}
				if (gbox.keyIsHit('right')) {
					this.move('right');
					//this.x += 1;
					this.n=0;
				}
				if (gbox.keyIsHit('up' )) {
					this.move('up');
					this.n=0;
				}
                if (gbox.keyIsHit('down')) {
					this.move('down');
					this.n = 0;
				}
				if (gbox.keyIsPressed('left')) {
					if (this.n>=min_key_frames) this.move('left'); //this.x -= 1;
					else this.n++;
				}
                if (gbox.keyIsPressed('right')) {
					if (this.n>=min_key_frames) this.move('right'); //this.x += 1;
					else this.n++;
				}
                if (gbox.keyIsPressed('up')) {
					if (this.n>=min_key_frames) this.move('up'); //this.y -= 1;
					else this.n++;
				}
                if (gbox.keyIsPressed('down')) {
					if (this.n>=min_key_frames) this.move('down'); //this.y += 1;
					else this.n++;
				}
                if (gbox.keyIsHit('r')) { // `OLD - this is for debugging only
					this.board.placeRandomTetrad(this.x, this.y);
				}
				if (gbox.keyIsHit('plus')) {
					// Largest scale of board that the player is allowed to be on:
					//   2^(player level)
					player = gbox.getObject('game', 'player');
					if (Math.pow(2, player.level)>this.board.scale)
						this.sizeup();
					else {
						correct_grammar = player.level==1? "a" : "another";
						display("You must eat " + correct_grammar + " stone monad before growing larger.");
					}
				}
				if (gbox.keyIsHit('minus')) {
					// The player can always sizedown.
					this.sizedown();
				}
				if (gbox.keyIsHit('space')) {
					// See if a tetrad can be eaten on the smaller board
					if (this.board.last_board_id != this.board.id) {  
						last_board = getBoard(this.board.last_board_id);
						t = last_board.getTetrad(this.x, this.y);
						if (t.indexOf(null)==-1) {
							// Start the eating animation
							this.t=t;
							this.anim_state = "eat_tetrad";
							this.anim_count = 0;
						}
					}
					// See if a whole monad can be eaten
					if (this.board.isWholeMonad(this.x, this.y)) {
						var m = this.board.getMonad(this.x, this.y);
						console.log("MONAD:", m);
						if (m!=blank) {
							this.m=m;
							this.anim_state="eat_monad";
							this.anim_count=0;
						}
					}
				}
				
            },
            blit: function() {
				pointCamera();
				
				// this variable is just for conciseness
				var s = this.board.scale/2; 
				
                gbox.blitTile(gbox.getBufferContext(), { 
                    tileset: this.tileset,
                    tile: this.frame,
					dx: this.board.x + this.x*tilesize - s*(1+cursor_x),
					dy: this.board.y + this.y*tilesize - s*(1+cursor_y),
                    fliph: this.fliph,
					flipv: this.flipv,
					scale_size: s,
                    camera: this.camera,
					alpha: 1.0
                });
            }
        };
    }
	function background() {
        return {
            id: 'background',
            group: 'background',
            initialize: function() {},
            first:      function() {
				board = getBoard('b1');
				if (gbox.keyIsHit('tab')) {
					for (var y=0; y<board_height; y++) {
					for (var x=0; x<board_width; x++) {
						var t = board_layers[0].getTetrad(x, y, 'wrap');
						board.map[y][x] = generateMonad(t);
					}}
					board_layers[0].refreshTilemap();
				}
				
				// Load a new board
				if (gbox.keyIsHit('n')) loadNewBoard(tut3, ['a']);
			},
            blit:       function() {
				clearBuffer();
				/*`TODO: Draw a wall around the whole board/landscape.
					- Blit a black filled rectangle from board_x0-tilesize to board_x0+board_width*tilesize
					(and similar for the y direction)
					
					-Blit a white 1-pixel border around the rectangle
						
					- Blit a white inner border
				*/
			}
        };
    }
	function loadResources() {
        // Initialize Akihabara
        help.akihabaraInit({
            title:  'Monstrad',
			width:  640,
            height: 480,
            zoom:   1,
            splash: {background:"images/splash.png"} // Custom splash screen
        });
        
        // Images
        gbox.addImage('font_small', 'images/font.png');
        gbox.addImage('font_large', 'images/font_large.png');
        gbox.addImage('logo', 'images/logo.png');
        gbox.addImage('monad_tileset', 'images/monads.png');
        gbox.addImage('cursor', 'images/cursor.png');
        gbox.addImage('monster', 'images/monster_animation.png');
        
        // FONTS
        //gbox.addFont({ id: 'small', image: 'font_small', firstletter:' ', tileh:8, tilew:8, tilerow:255, gapx:0, gapy:0 });
        gbox.addFont({ id: 'small', image: 'font_small', firstletter:' ', tileh:24, tilew:11, tilerow:255, gapx:0, gapy:0 });
         gbox.addFont({ id: 'large', image: 'font_large', firstletter:' ', tileh:16, tilew:16, tilerow:510, gapx:0, gapy:0 });
        
        // MONAD TILESETS
        gbox.addTiles({
            id:  'monad_tiles',
            image: 'monad_tileset',
            tileh:tilesize, tilew:tilesize, tilerow:4,
            gapx:0, gapy:0
        });
        
        // STATIC MONSTER CURSOR
        gbox.addTiles({
            id:    'cursor_tile',
            image: 'cursor',
			tilew: cursor_width,
			tileh: cursor_height,
			tilerow: 1,
            //tileh: 2*tilesize+2+9+4, tilew: 2*tilesize+2+6, tilerow: 1,
            gapx:  0,  gapy:  0
        });
        
        // MONSTER ANIMATION CURSOR
		gbox.addTiles({
			id: 'monster_tiles',
			image: 'monster',
			tilew: cursor_width,
			tileh: cursor_height,
			tilerow: 20,
			gapx:0,
			gapy:0
		});
		
        gbox.loadAll(main);
    }
    
    </script>
</html>
